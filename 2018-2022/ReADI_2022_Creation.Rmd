---
title: "<center>Reproducible Area Deprivation Index (ReADI | 2022)</center>"
author: "<br><center>[Nicole Gladish, PhD](https://profiles.stanford.edu/nicole-gladish)</center>"
date: "<center>`r format(Sys.time(), '%d %B, %Y')`</center>"
output:
  html_document:
    includes:
      after_body: "../templates/NG_footer.html"
      in_header: "../templates/header.html"
    toc: true
    toc_depth: 2
    number_sections: true
    toc_float: 
      collapsed: true
      smooth_scroll: true
    css: "../templates/bootstrap.css"
    self_contained: true
---

<br><br>

```{css, echo = FALSE}
  /* General code block styling */
  pre {
    background-color: #2e2e2e;
    color: #f5f5f5;
    padding: 8px 12px;
    border-radius: 4px;
    font-family: "Courier New", monospace;
  }
  code {
      background-color: #2e2e2e;
    color: #f5f5f5;
    padding: 8px 12px;
    border-radius: 4px;
    font-family: "Courier New", monospace;
}
  .hljs{
  display: block;
  padding: 0.5em;
  background: #2e2e2e;
  color: #f5f5f5;
  }

  /* Strings */
  .hljs-string {
      color: #c2a3fd; 
  }

  /* Numbers */
  .hljs-number, 
  .hljs-literal,
  .hljs-logical,
  .hljs-built_in, 
  .hljs-variable.constant,
  .hljs-keyword, 
  .hljs-variable.language, 
  .hljs-title.function{
      color: #8fff84; 
  }

  /* Comments */
  .hljs-comment, .hljs-quote {
      color: #ff7777; 
  }

  /* Symbols and punctuation (e.g., parentheses, brackets) */
.hljs-punctuation, .hljs-operator {
      color: #13cee0; 
  }
  
  /* General card block styling */
  
div.card {
    background-color: #71797E; /* Dark background color */
    border-radius: 10px;
    padding: 10px;
    color: white; /* Set text color to white */
    margin-bottom: 0;
    margin-top: 10px; /* Add some space above paragraphs if needed */
  }
   /* Explicitly set all header text inside .card to white (in case bootstrap overrides it) */
  div.card h1, div.card h2, div.card h3, div.card h4, div.card h5, div.card h6 {
    color: white; /* Set header text color to white */
  }
```

```{r setup, include=FALSE}
## Warn if R version is older than what was used for this analysis
if (getRversion() < "4.5.0") {
  warning(
    "This analysis was developed under R 4.5.0 ",
    "You are using R ", as.character(getRversion()),
    ". If you see package errors, consider upgrading to at least R 4.5.0"
  )
}

## Check for required packages and fail with a clear message if missing
needed_pkgs <- c(
  "tidyverse",
  "censusapi",
  "reshape2",
  "plyr",
  "SciViews",
  "readxl",
  "tidycensus",
  "psych",
  "tigris",
  "spdep",
  "statar",
  "dbplyr"
)

missing_pkgs <- needed_pkgs[
  !vapply(needed_pkgs, requireNamespace, logical(1), quietly = TRUE)
]

if (length(missing_pkgs) > 0) {
  msg <- paste0(
    "The following R packages are missing: ",
    paste(missing_pkgs, collapse = ", "), ".\n\n",
    "Please run renv::restore() in the project root for this year\n",
    "before knitting this document.\n\n",
    "If renv::restore() fails, see the README for this year\n",
    "for operating system–specific setup instructions."
  )
  stop(msg, call. = FALSE)
}

## Global options
options(tigris_use_cache = TRUE)
```

# Introduction

------------------------------------------------------------------------

<br>

This document provides a fully reproducible workflow for creating the 2022 Reproducible Area Deprivation Index (ReADI) for U.S. census block groups, tracts, and counties. ReADI is a corrected and updated implementation of the Area Deprivation Index that addresses several limitations of the existing Neighborhood Atlas ADI (NA-ADI), while preserving the core goal of summarizing socioeconomic deprivation across small areas.

Broadly, this workflow:

1.  Retrieves 2018–2022 5-year American Community Survey (ACS) data at county, tract, and block group levels.
2.  Cleans and harmonizes the ACS variables required to construct deprivation components.
3.  Imputes missing values using spatial information (neighboring areas) where appropriate.
4.  Constructs a set of standardized component variables that represent different dimensions of deprivation (income, education, employment, housing, etc.).
5.  Fits a one-factor, population-weighted factor model and uses the resulting factor scores as the basis for ReADI.
6.  Converts ReADI scores to a 0–100 national rank, with higher values indicating greater deprivation.

The primary goal of this document is transparency and accountability: to make every step of ReADI construction visible to the field so that it can be scrutinized, improved, and iteratively refined into the most accurate and informative measure possible. In addition, the code is written so that users can, if they wish, rerun the full workflow to regenerate ReADI or adapt individual pieces of the code for their own analyses.

## Overview {.tabset}

------------------------------------------------------------------------

The original Area Deprivation Index (ADI) as described by Singh was designed to summarize multiple socioeconomic indicators into a single deprivation score at relatively small area levels. [Singh (2003)](https://ajph.aphapublications.org/doi/pdf/10.2105/AJPH.93.7.1137) created the area deprivation index (ADI) which is a factor-based deprivation index comprised of 17 measures including poverty, education, housing and employment indicators drawn from US Census data to create a measure of socioeconomic context for a particular census-based region.

The [Neighborhoood Atlas (NA-ADI)](https://www.neighborhoodatlas.medicine.wisc.edu/) [(Kind et al. 2018)](https://www.nejm.org/doi/full/10.1056/NEJMp1802313) is a widely used operationalization of the ADI and has become the de facto standard deprivation index in many U.S. health studies. However, it has several practical limitations for ongoing analytic work, including fixed historical coefficients, lack of regular updating to contemporary ACS data, and limited transparency around how certain decisions were made (e.g., standardization, thresholds, and handling of missing data).

The following subsections summarize the main conceptual issues with NA-ADI and how ReADI addresses each of them in practice.

### Singh Methods

<br>

<h4>SINGH (2003)</h4>

<strong><strong>1.</strong></strong> Singh took 21 socioeconomic indicators and performed factor analysis on them using 1990 census data. This resulted in two factors represented in 43% and 17% of the variance with 17 measures clustering with large loading (\>0.45) on the first factor and so these 17 were selected and then re-run on factor analysis with a one factor solution producing the factor loading scores listed in the table below. These weights accounted for 52% of the variance in the data.

<strong><strong>2.</strong></strong> The factor score coefficients were used to weight the 17 indicators comprising the index.

<strong><strong>3.</strong></strong> The factor scale was transformed into a standardized index by arbitrarily setting the index mean and standard deviation at 100 and 20, respectively.

<strong><strong>4.</strong></strong> The tract index scores were averaged to allow computation of index scores for each of the 3097 US counties.

<strong><strong>5.</strong></strong> Higher index scores denote higher levels of deprivation.

<br>

### Kind Methods

<br>

<h4>Version 1 (5/1/2018)</h4>

<strong><strong>1.</strong></strong> [Kind et al. (2014)](https://www.acpjournals.org/doi/10.7326/M13-2946) used [Singh (2003)](https://ajph.aphapublications.org/doi/pdf/10.2105/AJPH.93.7.1137) methods, using the 17 indicators from 2000 census data and tract level factor score coefficients from [Singh (2003)](https://ajph.aphapublications.org/doi/pdf/10.2105/AJPH.93.7.1137).

<strong><strong>2.</strong></strong> The 17 US Census variables were multiplied by their factor weights and then summed for each geographic unit.

<strong><strong>3.</strong></strong> The result is then transformed into a standardized index (the ADI) by arbitrarily setting the index mean at 100 and standard deviation at 20.

<strong><strong>4.</strong></strong> Using this approach, neighborhoods with higher ADI scores have higher levels of deprivation. All coefficients are multiplied by -1 to ease interpretation (greater ADI means a greater disadvantage).

<br>

<h4>Version 2 (5/1/2019)</h4>

Every step in the methodology is the same as v1 except:

<strong><strong>1.</strong></strong> Same as v1 except there was the suppression of CBGs was based on those with \<100 people, fewer than 30 housing units, or \>33% of the population living in group quarters based on [Diez et al. (2001)](https://www.sciencedirect.com/science/article/pii/S1047279701002216).

<br>

<h4>Version 3.0 (11/19/2020)</h4>

Every step in the methodology is the same as v2 except:

<strong><strong>1.</strong></strong> Two methodological changes have been implemented to address missing Census Block Group level data in the underlying ACS data, survey errors and a new geographically-nested imputation method: <strong><strong>a)</strong></strong> Additional suppression of a small number of CBGs with survey errors acknowledged by the US Census Bureau. <strong><strong>b)</strong></strong> Imputation of missing ACS items using a geographically-nested imputation methodology consistent with other area deprivation indices methodologies, including the English Indices of Multiple Deprivation (IMD) and the Scottish Indices of Multiple Deprivation (SIMD).

<br>

<h4>Version 3.1 (7/14/2021)</h4>

Every step in the methodology is the same as v3.0 except:

<strong><strong>1.</strong></strong> Suppression criteria was updated to use Population, Housing and Group Quarters estimates from the ACS in place of the decennial Census. This adjusts the ADI of approximately 70 block groups nationally.

<br>

<h4>Version 3.2 (9/16/2022)</h4>

Every step in the methodology is the same as v3.1 except:

<strong><strong>1.</strong></strong> The No Phone variable was removed from the ADI and replaced with a No Household Internet variable to reflect the change in household phone and internet service.

<br>

<h4>Version 4.0.0 (7/10/2023)</h4>

Every step in the methodology is the same as v3.2 except:

<strong><strong>1.</strong></strong> The v4 ADI has minor standard shrinkage statistical updates included to mitigate the effect of year-to-year sampling variations in block group level component estimates within American Community Survey (ACS) data. This results in very little actual change in ADI ranking but buffers from known and future expected variation in ACS source data.

<br>

<h4>Version 4.0.1 (9/9/2023)</h4>

Every step in the methodology is the same as v4.0.0 except:

<strong><strong>1.</strong></strong> The v4.0.1 ADI has minor refined shrinkage statistical updates to improve the precision of the block group level component estimates derived from the American Community Survey (ACS) data. This results in slight shifts to the block group rankings from the previous version while retaining the general pattern and improving the overall temporal stability of the ADI. Using Census Block Groups, Nine Digit ZIP Code Centroids geography.

<br>

##  {.unnumbered}

> Factor Analysis Results 1990 Census Data (Singh 2003)

| Census Variable | Tract Score Coefficient | Tract Loading | County Loading |
|------------------|------------------|------------------|------------------|
| Population aged ≥25 y with \< 9 y of education, % | 0.0849 | 0.7498 | 0.7885 |
| Population aged ≥25 y with at least a high school diploma, % | –0.0970 | -0.8562 | -0.8231 |
| Employed persons aged ≥16 y in white-collar occupations, % | –0.0874 | -0.7721 | -0.6890 |
| Median family income, \$ | –0.0977 | -0.8629 | -0.9218 |
| Income disparity$^a$ | 0.0936 | 0.8262 | 0.8827 |
| Median home value, \$ | –0.0688 | -0.6074 | -0.6740 |
| Median gross rent, \$ | –0.0781 | -0.6896 | -0.7876 |
| Median monthly mortgage, \$ | –0.0770 | -0.6795 | -0.7812 |
| Owner-occupied housing units, % | –0.0615 | -0.5431 | -0.4408 |
| Civilian labor force population aged ≥16 y unemployed, % | 0.0806 | 0.7117 | 0.5679 |
| Families below poverty level, % | 0.0977 | 0.8623 | 0.8796 |
| Population below 150% of the poverty threshold, % | 0.1037 | 0.9157 | 0.9266 |
| Single-parent households with children aged \< 18 y, % | 0.0719 | 0.6346 | 0.3329 |
| Households without a motor vehicle, % | 0.0694 | 0.6126 | 0.4549 |
| Households without a telephone, % | 0.0877 | 0.7748 | 0.7830 |
| Occupied housing units without complete plumbing, % (log) | 0.0510 | 0.4505 | 0.6392 |
| Households with more than 1 person per room, % (crowding) | 0.0556 | 0.4910 | 0.4018 |

<sup>$^a$ Income disparity in 1990 was defined as the log of 100×ratio of number of households with \<\$10,000 income to number of households with ≥\$50,000 income.</sup>

<br>

## NA-ADI Issues {.tabset}

------------------------------------------------------------------------

Several limitations of the NA-ADI as implemented by [2014 Kind et al.](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4251560/pdf/nihms619606.pdf) and distributed via the [Neighbourhood Atlas](https://www.neighborhoodatlas.medicine.wisc.edu/) have important implications for current analytic work. In the tabs below, we outline four key issues: standardization, use of historical versus concurrent coefficients, updating variable thresholds, and population size adjustment. We also describe how ReADI addresses each of them. This section is meant to make those decisions explicit and open to scrutiny so the index can be transp

<br>

### Standardization

<h4>Problem</h4>

The most consequential technical problem with the NA-ADI is the lack of appropriate standardization when applying [Singh’s](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1447923/pdf/0931137.pdf) factor loadings to new ACS data. While this cannot be definitively confirmed because no code for the Neighborhood Atlas ADI has been published, [Petterson (2023)](https://academic.oup.com/healthaffairsscholar/article/1/5/qxad063/7342005) was able to reverse engineer the index to an R² ≥ 0.999 simply by standardizing the component variables before applying Singh’s published weights. This level of agreement strongly supports the conclusion that the missing standardization step is the main source of the discrepancy in the NA-ADI implementation. Factor analysis assumes variables are on a comparable scale, and standard practice in software such as SAS PROC FACTOR, Stata, and R is to standardize variables internally before estimating loadings. This is especially important here because the ADI components are on very different scales: most are proportions between 0 and 1, while four are dollar-valued medians with ranges from a few thousand to several hundred million dollars. Without standardization, variables with larger numeric ranges dominate the factor solution. Based on Singh’s description of using v8.1 SAS/STAT FACTOR and the [documentation](https://documentation.sas.com/doc/en/statcdc/14.2/statug/statug_factor_syntax01.htm) for that procedure, it is highly likely that the original ADI loadings were estimated on standardized variables, with that step handled automatically by the software. In contrast, the NA-ADI implementation did not re-fit the factor model but instead took Singh’s published loadings and applied them directly to raw ACS variables. As those new variables were not first standardized in the same way as in the original factor analysis, the resulting index is mathematically inconsistent with the model that produced the loadings which resulted in an overemphasize of components such as median home value.

<h4>Solution</h4>

In ReADI, we fit the factor model separately for each geography (county, tract, block group) and ACS period, rather than reusing historical loadings. The factor analysis is implemented in R (using psych::fa), which operates on the correlation matrix of the input variables and therefore centers and scales them internally. As a result, the component variables are placed on a common standardized scale as part of the model fitting, and we can directly use the resulting factor scores from that function as the raw ReADI values for that geography and year.

<br>

### Concurrent & Geographically Consistent Coefficients

<h4>Problem</h4>

[Kind et al. (2014)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4251560/pdf/nihms619606.pdf) report in their Table 1 that the coefficients (factor loadings) used for the NA-ADI are identical to those published by [Singh (2003)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1447923/pdf/0931137.pdf) based on 1990 census data. This implies that all subsequent NA-ADI vintages reuse the same 1990-era weights, even when applied to much more recent ACS data. Given substantial changes in the socioeconomic distribution over time, it is unlikely that factor loadings estimated on 1990 data remain appropriate for contemporary indices. Notably, when Singh evaluated temporal stability, he reconstructed the ADI using 1970 census data and recomputed the factor loadings for that decade, rather than reusing the 1990 coefficients. In other words, Singh’s own validation work did not rely on a single fixed set of weights across time.

In addition, the original ADI factor analysis was conducted at the census tract level, yet the [Neighborhood Atlas](https://www.neighborhoodatlas.medicine.wisc.edu/) NA-ADI is distributed and promoted primarily at the census block group level. This means tract-level loadings are being applied to block group–level variables, which assumes that the factor structure is invariant across spatial scale. The Neighborhood Atlas documentation also discourages users from aggregating NA-ADI to higher levels such as tracts or counties, even though its own coefficients were derived at the tract level. Taken together, this raises concerns about both temporal and geographic inconsistency in the NA-ADI weights.

<h4>Solution</h4>

In ReADI, we re-estimate the factor model for each ACS period and for each geographic level (county, tract, and block group) using the corresponding contemporary data. For every combination of year and geography, we fit a one-factor model in R (using *psych::fa*) with the chosen set of component variables and population-based weights. The resulting loadings and factor scores are therefore concurrent with the data to which they are applied and are specific to the spatial scale at which the index is used. This avoids relying on decades-old, tract-derived coefficients for block group–level analyses and ensures that ReADI reflects current relationships between the component variables and deprivation within each geography.

<br>

### Updating Variable Thresholds

<h4>Problem</h4>

[Kind et al. (2014)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4251560/pdf/nihms619606.pdf) list in their appendix the same variables and thresholds that [Singh (2003)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1447923/pdf/0931137.pdf) used with 1990 census data. As a result, most NA-ADI vintages rely on variable definitions and cut points that reflect socioeconomic conditions more than 30 years old. This is problematic for several reasons. Education thresholds based on less than 9 years of schooling and “higher education” defined as high school graduation are likely to underestimate educational deprivation in 2022, when completing high school is far more common and a bachelor’s degree is often a more appropriate benchmark. The income disparity bands used in the original ADI also do not account for changes in the income distribution or inflation (for example, very low income defined as less than \$10,000 and high income as at least \$50,000). Although the Neighborhood Atlas team has more recently updated the “telephone” variable to reflect internet access, many of the other original thresholds have not been modernized. Importantly, when Singh evaluated temporal stability using 1970 census data, he redefined at least the income disparity thresholds, which suggests that the original intent was to update these definitions over time rather than freeze them permanently.

<h4>Solution</h4>

In ReADI, we update key variable definitions and thresholds to better reflect contemporary socioeconomic conditions while preserving the underlying constructs. Specifically:

-   The original “percent of the population aged ≥ 25 years with less than 9 years of education” is replaced with “percent of the population aged ≥ 25 years with less than a high school diploma.”

-   The original “percent of the population aged ≥ 25 years with less than a high school diploma” is replaced with “percent of the population aged ≥ 25 years with less than a bachelor’s degree.”

-   The original income disparity measure

    $\text{Income Disparity} = log(100*{\text{Household Income <\$10,000} \over \text{Household Income ≥\$50,000}})$ is updated to $\text{Income Disparity} = log(100*{\text{Household Income <\$20,000} \over \text{Household Income ≥\$100,000}})$

which better reflects the current income distribution.

<br>

### Population Size Adjustment

<h4>Problem</h4>

Counties, census tracts, and census block groups have highly variable and skewed population sizes. Some units have only a handful of residents, while others contain thousands (and counties can range from a few hundred to several million people). Without accounting for these differences, small areas can contribute as much to the factor solution as large areas, which can make estimates unstable and distort comparisons both within and across geographic levels.

<h4>Solution</h4>

To account for this, we transform population size using the natural log of the total population and use this transformed measure as an analytic weight in the factor analysis. In practice, we compute a log population term (POPWT) and pass it as the *weight* argument to the factor analysis function. This gives more influence to more populous areas when estimating loadings and factor scores, while still producing ReADI values for each individual geographic unit.

<br>

# ReADI Preparation

------------------------------------------------------------------------

> Libraries

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code338">Show Code</button>

::: {#code338 .collapse}
```{r, results = F, message = F}
library(tidyverse)
library(censusapi)
library(reshape2) 
library(plyr) 
library(SciViews) 
library(readxl) 
library(tidycensus) 
library(psych)
options(tigris_use_cache = TRUE)
library(tigris)
library(spdep)
library(statar)
library(dbplyr)
```

```{r}
sessionInfo()
```
:::
::::

<br><br>

## Retrieving 2018-2022 5-Year ACS

------------------------------------------------------------------------

<br>

> Pulling Variables Required

<br>

In this section we obtain the ACS 2018–2022 5-year estimates for all variables used to construct ReADI. We work at three geographic levels: counties, census tracts, and census block groups. Definitions of these geographic units are provided in the [U.S. Census Bureau documentation](https://www2.census.gov/geo/pdfs/reference/GARM/Ch10GARM.pdf).

Accessing ACS data via the Census API requires an API key, which can be requested from the [Census Bureau](https://api.census.gov/data/key_signup.html). Once you receive your key, install it in your R environment as the *CENSUS_API_KEY* environment variable (for example, by adding it to *\~/.Renviron* or a project *.Renviron*) and do not hard-code the key directly in shared code.

The code that follows pulls the required ACS variables for counties, census tracts, and census block groups using the Census API and saves them as R objects for use in later steps.

Below are the final numbers of areas at each geography:

::::: row
::: col-md-4
| Area   | Amount  |
|:-------|:--------|
| CBG    | 242,336 |
| CT     | 85,396  |
| County | 3,222   |
:::

::: col-md-8
:::
:::::

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code397">Show Code</button>

::: {#code397 .collapse}
```{r}
if (!nzchar(Sys.getenv("CENSUS_API_KEY"))) {
  stop(
    "Census API key not found.\n",
    "Please set the CENSUS_API_KEY environment variable (e.g. in .Renviron) ",
    "before running this document.\n")}

states <- setdiff(unique(fips_codes$state_code), c("60", "66", "69", "74", "78")) # Removing US territories

ADI_Vars <- c(
       "B01003_001",
       "B19013_001",
       "B19001_002", "B19001_003", "B19001_004", "B19001_014", "B19001_015", "B19001_016", "B19001_017", 
       "B17017_002", "B17017_001", 
       "C17002_005", "C17002_004", "C17002_003", "C17002_002", "C17002_001", 
       "B15003_001", "B15003_002", "B15003_003", "B15003_004", "B15003_005", "B15003_006", "B15003_007", "B15003_008", "B15003_009", "B15003_010", "B15003_011", "B15003_012", "B15003_013", "B15003_014", "B15003_015", "B15003_016", "B15003_022", "B15003_023", "B15003_024", "B15003_025",
       "C24010_003", "C24010_027", "C24010_039", "C24010_063", "C24010_001",
       "B23025_005", "B23025_003",
       "B25077_001", 
       "B25064_001", 
       "B25088_002", 
       "B25003_001", "B25003_002",
       "B11012_010", "B11012_015", "B11012_001", 
       "B25044_003", "B25044_010", "B25044_001", 
       "B28002_013", "B28002_001",
       "B25049_007", "B25049_004", "B25049_001", 
       "B25014_005", "B25014_006", "B25014_007", "B25014_011", "B25014_012", "B25014_013", "B25014_001")
  
# CBG level
ACS_CBG <- do.call(rbind, lapply(states, function(st) {
get_acs(
    year = 2022,
    geography = "block group",
    state = st,
    key = Sys.getenv("CENSUS_API_KEY"),
    variables = ADI_Vars)
}))
ACS_CBG <- dcast(ACS_CBG, GEOID + NAME ~ variable, value.var=c("estimate"))
ReADI_2022_CBG_Raw <- ACS_CBG %>% separate(NAME, c("Block_Group", "Tract", "County", "State"), sep = ";") 

# census tract level
ACS_CT <- do.call(rbind, lapply(states, function(st) {
get_acs(
    year = 2022,
    geography = "tract",
    state = st,
    key = Sys.getenv("CENSUS_API_KEY"),
    variables = ADI_Vars)
}))

ACS_CT <- dcast(ACS_CT, GEOID + NAME ~ variable, value.var=c("estimate"))
ReADI_2022_CT_Raw <- ACS_CT %>% separate(NAME, c("Tract", "County", "State"), sep = ";") 

# county level
ACS_C <- do.call(rbind, lapply(states, function(st) {
get_acs(
    year = 2022,
    geography = "county",
    state = st,
    key = Sys.getenv("CENSUS_API_KEY"),
    variables = ADI_Vars)
}))

ACS_C <- dcast(ACS_C, GEOID + NAME ~ variable, value.var=c("estimate"))
ReADI_2022_C_Raw <- ACS_C %>% separate(NAME, c("County", "State"), sep = ",") 
```
:::
::::

<br><br>

> Pulling Geography Measures

<br>

In addition to the ACS variables, we retrieve the corresponding spatial geometries for each geography (counties, census tracts, and census block groups). These geometry objects are required for both the spatial imputation procedures and for any visualizations that involve mapping ReADI values. The code in this section downloads and stores the geometry data that will be linked to the ACS variables in later steps.

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code478">Show Code</button>

::: {#code478 .collapse}
```{r}
CBG_Geo <- do.call(rbind, lapply(states, function(st) {
get_acs(
    year = 2022,
    geography = "block group",
    geometry = TRUE,
    state = st,
    key = Sys.getenv("CENSUS_API_KEY"),
    variables = "B01003_001")
}))
CBG_Geo <- CBG_Geo[!CBG_Geo$estimate == 0,] 
ACS_CBG_2022_Geometry <- CBG_Geo[, c("GEOID", "geometry")]

CT_Geo <- do.call(rbind, lapply(states, function(st) {
   get_acs(
    year = 2022,
    geography = "tract",
    geometry = TRUE,
    state = st,
    key = Sys.getenv("CENSUS_API_KEY"),
    variables = "B01003_001")
}))
CT_Geo <- CT_Geo[!CT_Geo$estimate == 0,] 
ACS_CT_2022_Geometry <- CT_Geo[, c("GEOID", "geometry")]

C_Geo <- do.call(rbind, lapply(states, function(st) {
get_acs(
    year = 2022,
    geography = "county",
    geometry = TRUE,
    state = st,
    key = Sys.getenv("CENSUS_API_KEY"),
    variables = "B01003_001")
}))
C_Geo <- C_Geo[!C_Geo$estimate == 0,] 
ACS_C_2022_Geometry <- C_Geo[, c("GEOID", "geometry")]
```
:::
::::

<br><br>

## Group Quarters & Small Populations

------------------------------------------------------------------------

<br>

The Neighborhood Atlas NA-ADI applies several suppression rules, excluding block groups with (1) ≥ 33% of residents in group quarters, (2) population \< 100 or \< 30 housing units, or (3) missing key ACS inputs (“QDI”), following guidance from [Roux et al. (2001)](https://www.sciencedirect.com/science/article/pii/S1047279701002216). These criteria remove a small fraction of areas nationally but disproportionately affect settings such as prisons, nursing homes, college dormitory tracts, and very small rural communities.

In ReADI, we do not automatically exclude these areas. Although estimates for group-quarters–heavy or very small-population units are inherently less precise, the factor analysis in ReADI is population-weighted, which substantially downweights their influence on the estimation of loadings and scores while still allowing these units to receive values. In many applications, these areas are themselves important to evaluate, and suppressing them by default can obscure relevant patterns.

Because we provide the code, raw factor scores and the nationally ranked ReADI scores, users who prefer to exclude or analyze these units separately can do so easily based on their own analytic requirements. This approach maximizes transparency and flexibility while minimizing the impact of imprecise units on the construction of the index itself.

<br><br>

## Population Size

------------------------------------------------------------------------

<br>

Some geographic units have no residents or correspond to areas such as open water, uninhabited land, or industrial zones. Because these units do not meaningfully contribute to the construction of a deprivation index and can interfere with both imputation and factor analysis, we remove them prior to processing. The table below summarizes the number of remaining units at each geographic level after this basic population filter is applied.

::::: row
::: col-md-4
| Area   | Pop = 0 | Remaining |
|:-------|:--------|:----------|
| CBG    | 2,164   | 240,172   |
| CT     | 857     | 84,539    |
| County | 0       | 3,222     |
:::

::: col-md-8
:::
:::::

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code559">Show Code</button>

::: {#code559 .collapse}
```{r}
ReADI_2022_CBG_Raw <- ReADI_2022_CBG_Raw[!ReADI_2022_CBG_Raw$B01003_001 == 0,] 
ReADI_2022_CT_Raw <- ReADI_2022_CT_Raw[!ReADI_2022_CT_Raw$B01003_001 == 0,] 
ReADI_2022_C_Raw <- ReADI_2022_C_Raw[!ReADI_2022_C_Raw$B01003_001 == 0,] 
```
:::
::::

<br><br>

## Missing Values

------------------------------------------------------------------------

<br>

Table 1 below summarizes the extent of missing data for variables with incomplete information at each geographic level. Only a subset of components have any missing values, and for most variables the proportion of missingness is small.

::::: row
::: col-md-6
| Variable   | CBG N (/%) | CT N (/%) | C N (/%) |
|:-----------|:-----------|:----------|:---------|
| B19013_001 | 15042 (6)  | 724 (1)   | 1 (\<1)  |
| B25064_001 | 65920 (27) | 4392 (5)  | 10 (\<1) |
| B25077_001 | 21260 (9)  | 2344 (3)  | 3 (\<1)  |
| B25088_002 | 29910 (12) | 2796 (3)  | 6 (\<1)  |
:::

::: col-md-6
:::
:::::

<br>

Table 2 lists the 12 counties with missing values on at least one component variable. These counties are almost entirely very low population areas, which appears to be the primary source of ACS nonreporting. Kalawao County in Hawaii is a notable example: it is an isolated, historically protected community with a very small resident population, and several ACS estimates are suppressed or unavailable for this county.

:::: {style="margin:16px 0"}
<center>

<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code569">

<h4 class="text-white">

County NAs

</h4>

</button>

</center>

::: {#code569 .collapse}
| County, ST | Population | B19013_001 | B25064_001 | B25077_001 | B25088_002 |
|:-----------|:-----------|:-----------|:-----------|:-----------|:-----------|
| Alpine County, CA | 1,515 | \$101,125 | <strong><strong>NA</strong></strong> | \$463,900 | \$2,401 |
| Kalawao County, HI | 50 | \$87,813 | \$1,297 | <strong><strong>NA</strong></strong> | <strong><strong>NA</strong></strong> |
| Owsley County, KY | 4,054 | \$32,844 | <strong><strong>NA</strong></strong> | \$78,500 | \$947 |
| Cameron Parish, LA | 5,447 | \$69,847 | <strong><strong>NA</strong></strong> | \$177,600 | \$1,270 |
| Buffalo County, SD | 1,859 | \$42,917 | \$575 | \$103,800 | <strong><strong>NA</strong></strong> |
| Borden County, TX | 686 | \$80,625 | <strong><strong>NA</strong></strong> | \$104,200 | <strong><strong>NA</strong></strong> |
| Glasscock County, TX | 1,068 | \$112,188 | <strong><strong>NA</strong></strong> | \$258,300 | \$859 |
| Kenedy County, TX | 116 | \$45,455 | <strong><strong>NA</strong></strong> | <strong><strong>NA</strong></strong> | <strong><strong>NA</strong></strong> |
| King County, TX | 216 | \$59,375 | <strong><strong>NA</strong></strong> | <strong><strong>NA</strong></strong> | <strong><strong>NA</strong></strong> |
| Loving County, TX | 96 | <strong><strong>NA</strong></strong> | <strong><strong>NA</strong></strong> | \$218,800 | <strong><strong>NA</strong></strong> |
| Terrell County, TX | 862 | \$52,813 | <strong><strong>NA</strong></strong> | \$119,800 | \$1,274 |
| Daggett County, UT | 638 | \$61,250 | <strong><strong>NA</strong></strong> | \$252,400 | \$1,238 |
:::
::::

Across geographies, virtually all systematic missingness occurs in the four currency variables that are central to ADI construction (median family income, median home value, median rent, and median mortgage). In other words, the variables at the core of the standardization issues in the NA-ADI are also the ones that require imputation in ReADI. This concentration of missingness makes it especially important to handle imputation carefully, as decisions for these variables directly affect the resulting deprivation scores.

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code634">Show Code</button>

::: {#code634 .collapse}
```{r}
# By Variables
na_stats <- function(dat, vars) {
  n_miss <- colSums(is.na(dat[, vars, drop = FALSE]))
  perc   <- round(n_miss / nrow(dat) * 100, 2)
  list(N = n_miss, P = perc)
}

vars_cbg <- names(which(colSums(is.na(ReADI_2022_CBG_Raw)) > 0))

stopifnot(
  identical(vars_cbg, names(which(colSums(is.na(ReADI_2022_CT_Raw)) > 0))),
  identical(vars_cbg, names(which(colSums(is.na(ReADI_2022_C_Raw)) > 0))))

cbg <- na_stats(ReADI_2022_CBG_Raw, vars_cbg)
ct  <- na_stats(ReADI_2022_CT_Raw,  vars_cbg)
c   <- na_stats(ReADI_2022_C_Raw,   vars_cbg)

## combine into one data.frame
NA_Vars <- data.frame(
  Variable    = vars_cbg,
  CBG_N       = cbg$N,
  Perc_NA_CBG = cbg$P,
  CT_N        = ct$N,
  Perc_NA_CT  = ct$P,
  C_N         = c$N,
  Perc_NA_C   = c$P,
  row.names   = vars_cbg,
  check.names = FALSE)

# Missing by county
CountiesMissing <- ReADI_2022_C_Raw[rowSums(is.na(ReADI_2022_C_Raw)) > 0,]

# By Geo Area
NA_CBG_GEOs <- ReADI_2022_CBG_Raw[rowSums(is.na(ReADI_2022_CBG_Raw)) > 0,]
NA_CBG_GEOs <- as.data.frame(rowSums(is.na(NA_CBG_GEOs))) 
table(NA_CBG_GEOs[1]) # 4 max

NA_CT_GEOs <- ReADI_2022_CT_Raw[rowSums(is.na(ReADI_2022_CT_Raw)) > 0,]
NA_CT_GEOs <- as.data.frame(rowSums(is.na(NA_CT_GEOs))) 
table(NA_CT_GEOs[1]) # 4 max

NA_C_GEOs <- ReADI_2022_C_Raw[rowSums(is.na(ReADI_2022_C_Raw)) > 0,]
NA_C_GEOs <- as.data.frame(rowSums(is.na(NA_C_GEOs))) 
table(NA_C_GEOs[1]) # 4 max
```
:::
::::

<br><br>

### Imputation

------------------------------------------------------------------------

<br>

We use spatial imputation to address missing values in a small subset of key variables before constructing ReADI. For each geography (block group, tract, county), missing values are imputed using neighboring units defined by queen contiguity within state (polygons that share a border or a vertex).

In brief, the procedure:

1.  Joins the variable of interest to its corresponding geometry within each state.
2.  Builds a queen-contiguity neighbor list using *spdep::poly2nb()*.
3.  Iteratively replaces missing values with the median of their neighbors’ values.
4.  Stops when no further values can be filled in using this rule.

Newly imputed values are allowed to contribute to subsequent iterations, so clusters of missingness are gradually filled in from their observed borders inward. Units that remain missing after this process are typically geographically isolated (for example, islands, national parks, or small federal facilities) or have neighbours that are all missing for that variable.

When running the spatial imputation function you may see warnings such as:

-   “some observations have no neighbours”
-   “neighbour object has X sub-graphs”

These messages are expected for real-world geographies and do not indicate that the imputation has failed. “No neighbors” means a polygon has no contiguous neighbors under queen contiguity and therefore cannot borrow information; “sub-graphs” indicates that the adjacency graph is split into separate clusters (for example, mainland vs islands), and imputation is carried out within each cluster separately.

We do not force additional neighbors (for example, by using large snapping tolerances or k-nearest-neighbor rules) because that would introduce arbitrary spatial relationships that are difficult to justify. A small number of units are therefore expected to remain missing after spatial imputation and are handled explicitly in later steps.

> Imputation Functions

The following code defines the reusable functions used for spatial imputation at each geography:

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code723">

Imputation Function

</button>

::: {#code723 .collapse}
```{r}
impute.fun <- function(data, var, shape) {
  # pull GEOID + variable, rename to "estimate"
  variable <- data[, c("GEOID", var)]
  colnames(variable) <- c("GEOID", "estimate")
  message(paste0(sum(is.na(variable$estimate)), " missing before imputation."))

  # join onto shape and drop invalid geometries
  df <- dplyr::left_join(shape, variable, by = "GEOID")
  df <- df[!is.na(sf::st_dimension(df)), ]

  df$State <- substr(df$GEOID, 1, 2)
  df$raw.estimate <- df$estimate

  n <- nrow(df)
  states <- df$State
  state_levels <- unique(states)

  # precompute row indices per state
  idx_list <- split(seq_len(n), states)

  # precompute neighbour lists per state (geometry only)
  nb_list <- vector("list", length(state_levels))
  names(nb_list) <- state_levels
  for (st in state_levels) {
    idx <- idx_list[[st]]
    nb_list[[st]] <- spdep::poly2nb(df[idx, ], queen = TRUE)
  }

  imputed_last <- rep(NA_real_, n)  # will hold the last round of neighbour medians

  repeat {
    missing_pre <- sum(is.na(df$estimate))

    # compute neighbour medians for current estimates
    imputed <- rep(NA_real_, n)
    for (st in state_levels) {
      idx <- idx_list[[st]]
      est_state <- df$estimate[idx]
      nb_state  <- nb_list[[st]]

      imputed[idx] <- vapply(
        nb_state,
        function(z) stats::median(est_state[z], na.rm = TRUE),
        numeric(1)
      )
    }

    # keep a copy of the latest neighbour medians
    imputed_last <- imputed

    # same logic as before: only fill where estimate is NA
    na_pos <- which(is.na(df$estimate))
    df$estimate[na_pos] <- imputed[na_pos]

    missing_post <- sum(is.na(df$estimate))
    if (missing_post >= missing_pre) break
  }

  # attach the final neighbour-median predictions
  df$imputed <- imputed_last

  message(paste0(sum(is.na(df$estimate)), " missing after imputing."))
  df
}

impute_vars <- function(data, shape, vars, level_label = "") {
  # inner helper for a single variable
  impute_one <- function(var_name) {
    msg_suffix <- if (nzchar(level_label)) paste0(" at ", level_label, " level") else ""
    message("Imputing ", var_name, msg_suffix, " ...")

    df_imp <- impute.fun(
      data  = data,
      var   = var_name,
      shape = shape
    )

    # diagnostics (same as you had)
    message("Correlation (estimate vs raw) for ", var_name)
    print(cor.test(df_imp$estimate, df_imp$raw.estimate))

    message("Correlation (imputed vs raw) for ", var_name)
    print(cor.test(df_imp$imputed, df_imp$raw.estimate))

    # drop geometry, keep GEOID + estimate, rename back to original var name
    df_imp$geometry <- NULL
    out <- df_imp[, c("GEOID", "estimate")]
    names(out)[names(out) == "estimate"] <- var_name

    out
  }

  # run for all vars
  res_list <- lapply(vars, impute_one)

  # combine like your chained plyr::join calls
  imputed <- plyr::join_all(res_list, by = "GEOID", type = "left")

  # NA check (same info you were printing manually)
  na_counts <- sapply(vars, function(v) sum(is.na(imputed[[v]])))
  message("Remaining NAs by variable:")
  print(na_counts)

  imputed
}
```
:::
::::

> Block group (CBG) imputation

At the census block group level, spatial imputation is applied to the subset of variables with missing values. Only originally missing values are replaced; observed values are retained unchanged. Table below summarizes the number and proportion of missing values for each imputed variable before and after CBG-level imputation.

::::: row
::: col-md-6
| Variable   | $r$   | *p*value        | NAs Remaining |
|:-----------|:------|:----------------|:--------------|
| B19013_001 | 0.757 | $<2.2x10^{-16}$ | 14            |
| B25064_001 | 0.831 | $<2.2x10^{-16}$ | 29            |
| B25077_001 | 0.918 | $<2.2x10^{-16}$ | 14            |
| B25088_002 | 0.869 | $<2.2x10^{-16}$ | 15            |
:::

::: col-md-6
:::
:::::

The code below runs the imputation for block groups and produces the post-imputation dataset used in subsequent ReADI construction steps.

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code857">Show Code</button>

::: {#code857 .collapse}
```{r, warning = FALSE}
vars <- c("B19013_001", "B25064_001", "B25077_001", "B25088_002")
CBG_2022_Imputed <- impute_vars(
  data        = ReADI_2022_CBG_Raw,
  shape       = ACS_CBG_2022_Geometry,
  vars        = vars,
  level_label = "CBG")
ReADI_CBG_2022_Imp <- ReADI_2022_CBG_Raw[, !names(ReADI_2022_CBG_Raw) %in% vars]
ReADI_CBG_2022_Imp <- plyr::join(ReADI_CBG_2022_Imp, CBG_2022_Imputed, by = "GEOID")
```
:::
::::

> CT

The same spatial imputation strategy is applied at the census tract and county levels, using tract and county geometries and state-specific neighbor lists. For each geography, only originally missing values are imputed, and imputation proceeds iteratively within state until no additional units can be filled based on their neighbors.

::::: row
::: col-md-6
| Variable   | $r$   | *p*value        | NAs Remaining |
|:-----------|:------|:----------------|:--------------|
| B19013_001 | 0.802 | $<2.2x10^{-16}$ | 4             |
| B25064_001 | 0.839 | $<2.2x10^{-16}$ | 4             |
| B25077_001 | 0.920 | $<2.2x10^{-16}$ | 4             |
| B25088_002 | 0.894 | $<2.2x10^{-16}$ | 4             |
:::

::: col-md-6
:::
:::::

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code892">Show Code</button>

::: {#code892 .collapse}
```{r, warning = FALSE}
CT_2022_Imputed <- impute_vars(
  data        = ReADI_2022_CT_Raw,
  shape       = ACS_CT_2022_Geometry,
  vars        = vars,
  level_label = "CT")
ReADI_CT_2022_Imp <- ReADI_2022_CT_Raw[, !names(ReADI_2022_CT_Raw) %in% vars]
ReADI_CT_2022_Imp <- plyr::join(ReADI_CT_2022_Imp, CT_2022_Imputed, by = "GEOID")
```
:::
::::

> C

The same spatial imputation strategy is applied at the census tract and county levels, using tract and county geometries and state-specific neighbor lists. For each geography, only originally missing values are imputed, and imputation proceeds iteratively within state until no additional units can be filled based on their neighbors.

::::: row
::: col-md-6
| Variable   | $r$   | *p*value        | NAs Remaining |
|:-----------|:------|:----------------|:--------------|
| B19013_001 | 0.782 | $<2.2x10^{-16}$ | 0             |
| B25064_001 | 0.832 | $<2.2x10^{-16}$ | 0             |
| B25077_001 | 0.862 | $<2.2x10^{-16}$ | 0             |
| B25088_002 | 0.858 | $<2.2x10^{-16}$ | 0             |
:::

::: col-md-6
:::
:::::

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code926">Show Code</button>

::: {#code926 .collapse}
```{r, warning = FALSE}
## Remove DC for spatial imputation
data_no_dc  <- ReADI_2022_C_Raw[ReADI_2022_C_Raw$State != " District of Columbia", ]
geoid_dc    <- ReADI_2022_C_Raw[ReADI_2022_C_Raw$State == " District of Columbia", "GEOID"]
shape_no_dc <- ACS_C_2022_Geometry[!ACS_C_2022_Geometry$GEOID %in% geoid_dc, ]

C_2022_Imputed <- impute_vars(
  data        = data_no_dc,
  shape       = shape_no_dc,
  vars        = vars,
  level_label = "county (excluding DC)")

ReADI_C_2022_Imp <- ReADI_2022_C_Raw[, !names(ReADI_2022_C_Raw) %in% vars]
ReADI_C_2022_Imp <- plyr::join(ReADI_C_2022_Imp, C_2022_Imputed, by = "GEOID")

stopifnot(identical(ReADI_2022_C_Raw$GEOID, ReADI_C_2022_Imp$GEOID))

## Restore DC’s original values (they were excluded from imputation)
for (v in vars) {
  ReADI_C_2022_Imp[[v]] <- ifelse(
    is.na(ReADI_C_2022_Imp[[v]]),
    ReADI_2022_C_Raw[[v]],
    ReADI_C_2022_Imp[[v]]
  )}
```
:::
::::

<br><br>

### Remaining Missing Values After Spatial Imputation

------------------------------------------------------------------------

<br>

After the primary spatial imputation step, a small number of geographic units still have missing values. These remaining NAs occur almost entirely in areas that either (1) have no bordering geographies to borrow information from (for example, isolated tracts or block groups and islands) or (2) are special-use areas such as national parks, military or naval facilities, or other atypically enumerated locations. To handle these cases, we use a simple hierarchical approach: where units are clearly non-residential or special-use, we remove them from the analytic dataset; otherwise, we borrow information from the next-highest relevant geography.

<br><br>

### Counties

------------------------------------------------------------------------

<br>

No counties have missing values after spatial imputation.

<br><br>

### Census Tracts

------------------------------------------------------------------------

<br>

Four census tracts remain with missing values after imputation. Table below summarizes these tracts and their characteristics based on [Census Reporter](https://censusreporter.org/profiles/):

:::: {style="margin:16px 0"}
<center>
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code855">
<h4 class="text-white">CT NAs</h4></button>
</center>

::: {#code855 .collapse}
| GEOID | CT | Location | Population | CT Information |
|:--------------|:--------------|:--------------|:--------------|:--------------|
| 06083980100 | 9801 | Santa Barbara County, CA | 10 | Channel Islands National Park. |
| 06111980000 | 9800 | Ventura County, CA | 107 | Naval Facility San Nicolas Island. |
| 12087980100 | 9801 | Monroe County, FL | 2 | Dry Tortugas is a National Park. |
| 26083980100 | 9801 | Keweenaw County, MI | 3 | Isle Royale Island is a National Park. |
:::
::::

These tracts are either extremely small, geographically isolated, or special-use areas. For ReADI construction, these tracts are removed from the tract-level analytic dataset, and any block groups nested entirely within them are also excluded (see below).

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1015">Show Code</button>

::: {#code1015 .collapse}
```{r}
na_list <- lapply(vars, function(v) ReADI_CT_2022_Imp[is.na(ReADI_CT_2022_Imp[[v]]), c("GEOID", "Tract", "County", "State")])
CT_Missing <- unique(do.call(rbind, na_list))
ReADI_CT_2022_Imp <- ReADI_CT_2022_Imp[!ReADI_CT_2022_Imp$GEOID %in% CT_Missing$GEOID, ]
```
:::
::::

> Removing CBGs located within removed tracts

Thirty-two census block groups remain with missing values after block group level imputation. Of these, four are located within the census tracts removed above, and an additional three correspond to national parks or similar areas that are not appropriate for inclusion in a residential deprivation index. Table below lists these CBGs and their characteristics using [Census Reporter](https://censusreporter.org/profiles/):

:::: {style="margin:16px 0"}
<center>
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1023">
<h4 class="text-white">CBG NAs</h4></button>
</center>

::: collapse
| GEOID | CBG.CT | Location | Population | CT Information | Removed |
|:-----------|:-----------|:-----------|:-----------|:-----------|:-----------|
| 022200002006 | 6.2 | Sitka City & Borough, AK | 372 | Series of Islands |  |
| 060290057001 | 1.57 | Kern County, CA | 2,851 | Wherry Housing |  |
| 060375991001 | 1.5991 | Los Angeles County, CA | 201 | San Clemente Islands |  |
| 060839801001 | 1.9801 | Santa Barbara County, CA | 10 | Channel Islands National Park | <strong><strong>X</strong></strong> |
| 061119800001 | 1.9800 | Ventura County, CA | 107 | Naval Facility San Nicolas Island | <strong><strong>X</strong></strong> |
| 120379703041 | 1.9703.04 | Franklin County, FL | 970 | Saint George Island |  |
| 120879709001 | 1.9709 | Monroe County, FL | 1,033 | Lower Matecumbe Beach |  |
| 120879801001 | 1.9801 | Monroe County, FL | 2 | Dry Tortugas is a National Park | <strong><strong>X</strong></strong> |
| 230050044022 | 2.44.02 | Cumberland County, ME | 562 | Cousins Island |  |
| 230139711004 | 4.9711 | Knox County, ME. | 138 | Isle au Haut and Matinicus Isle |  |
| 230159756005 | 5.9756 | Lincoln County, ME | 119 | Monhegan Island |  |
| 250072004006 | 6.2004 | Dukes County, MA | 38 | Gosnold |  |
| 260839801001 | 1.9801 | Keweenaw County, MI | 3 | Isle Royale Island is a National Park | <strong><strong>X</strong></strong> |
| 260979505001 | 1.9505 | Mackinac County, MI | 44 | Bois Blanc Island |  |
| 360050001001 | 1.1 | Bronx County, NY | 4,446 | Rikers Island Prison | <strong><strong>X</strong></strong> |
| 360610240002 | 2.240 | New York County, NY | 2,278 | Manhattan Psychiatric Center | <strong><strong>X</strong></strong> |
| 360610240003 | 3.240 | New York County, NY | 38 | Waste Facility Plant |  |
| 360810916034 | 4.916.03 | Queens County, NY | 2,230 | Queens |  |
| 360810916035 | 5.916.03 | Queens County, NY | 444 | Queens |  |
| 360810916036 | 6.916.03 | Queens County, NY | 684 | Queens |  |
| 361031702061 | 1.1702.06 | Suffolk County, NY | 53 | Fishers Island |  |
| 370959201013 | 3.9201.01 | Hyde County, NC | 715 | Ocracoke Island |  |
| 390430419004 | 4.419 | Erie County, OH | 221 | Kelleys Island |  |
| 440050401052 | 2.401.05 | Newport County, RI | 98 | Prudance Park and Homestead on Island |  |
| 510010906001 | 1.906 | Accomack County, VA | 345 | Tangier Island |  |
| 530350927043 | 3.927.04 | Kitsap County, WA | 14 | Blake Island Marine State Park | <strong><strong>X</strong></strong> |
| 530530724101 | 1.724.10 | Pierce County, WA | 1,435 | Fox Island |  |
| 530530724102 | 2.724.10 | Pierce County, WA | 1,080 | Fox Island |  |
| 530530724103 | 3.724.10 | Pierce County, WA | 1,129 | Fox Island |  |
| 530530726033 | 3.726.03 | Pierce County, WA | 1,621 | Anderson Island |  |
| 530530726035 | 5.726.03 | Pierce County, WA | 371 | McNeil Island |  |
| 720531501062 | 2.1501.06 | Fajardo Municipio, PR | 38 | Palomino Island |  |
:::
::::

Block groups nested in removed tracts and clearly non-residential CBGs are dropped from the CBG-level analytic dataset.

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1087">Show Code</button>

::: {#code1087 .collapse}
```{r}
bad_len <- which(is.na(ReADI_CBG_2022_Imp$GEOID) | nchar(ReADI_CBG_2022_Imp$GEOID) != 12)
if (length(bad_len) > 0) {
  stop("Found invalid CBG GEOIDs (NA or not 12 chars). Example rows: ",
       paste(head(bad_len, 10), collapse = ", "))
}
cbg_na_list <- lapply(vars, function(v) ReADI_CBG_2022_Imp[is.na(ReADI_CBG_2022_Imp[[v]]), c("GEOID", "Tract", "County", "State")])
CBG_Missing <- unique(do.call(rbind, cbg_na_list))
CBG_Missing$GEOID_CT <- substr(CBG_Missing$GEOID, 1, 11)
CBG_rm <- CBG_Missing[CBG_Missing$GEOID_CT %in% CT_Missing$GEOID,]$GEOID
ReADI_CBG_2022_Imp <- ReADI_CBG_2022_Imp[!ReADI_CBG_2022_Imp$GEOID %in% CBG_rm, ]
```
:::
::::

<br><br>

### Final CBG Imputation Using Tract Values

------------------------------------------------------------------------

<br>

The remaining CBGs with missing values after the steps above are imputed using the corresponding census tract level values for the same variables. This preserves information from the broader local context while avoiding arbitrary spatial borrowing across unrelated areas. Table below summarizes the final counts of units retained at each geographic level (block group, tract, county) after all imputation and exclusion steps.

::::: row
::: col-md-4
:::

::: col-md-4
| Area | NAs | Amount  |
|:-----|:----|:--------|
| CBG  | 0   | 240,165 |
| CT   | 0   | 84,535  |
| C    | 0   | 3,222   |
:::

::: col-md-4
:::
:::::

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1129">Show Code</button>

::: {#code1129 .collapse}
```{r}
impute_CBG_geo <- CBG_Missing[!CBG_Missing$GEOID %in% CBG_rm,]
impute_data <- ReADI_CT_2022_Imp[ReADI_CT_2022_Imp$GEOID %in% impute_CBG_geo$GEOID_CT, c("GEOID", vars)]
colnames(impute_data) <- paste(colnames(impute_data), "_CT", sep = "")
ReADI_CBG_2022_Imp$GEOID_CT <- substring(ReADI_CBG_2022_Imp$GEOID, 1, 11)
ReADI_CBG_2022_Imp <- plyr::join(ReADI_CBG_2022_Imp, impute_data, by = "GEOID_CT", type = "left")
ReADI_CBG_2022_Imp[vars] <- lapply(vars, function(v) {ifelse(is.na(ReADI_CBG_2022_Imp[[v]]), ReADI_CBG_2022_Imp[[paste0(v, "_CT")]], ReADI_CBG_2022_Imp[[v]])})
ReADI_CBG_2022_Imp[c("GEOID_CT", paste0(vars, "_CT"))] <- NULL

sum(is.na(ReADI_CBG_2022_Imp))
sum(is.na(ReADI_CT_2022_Imp))
sum(is.na(ReADI_C_2022_Imp))
```
:::
::::

With all preprocessing complete, including variable assembly, population filtering, spatial imputation, and resolution of remaining missing values, the analytic datasets for counties, census tracts, and block groups are now fully prepared for index construction. The following section implements the ReADI model itself: calculating component variables, fitting the population-weighted factor model, extracting loadings and factor scores, and generating the final ReADI values and national percentile ranks for each geographic unit.

<br><br>

# ReADI Production

<br>

## Method

<br>

The steps below describe how ReADI is constructed at each geographic level (county, census tract, and census block group). Although the same procedure is applied across all three geographies, the models are estimated independently within each level so that the resulting loadings and scores are geographically appropriate.

<strong><strong>1. Construct the 17 component variables:</strong></strong> Using the imputed ACS data for each geography, we compute the 17 deprivation-related component variables used in ReADI. These variables represent domains such as income, education, employment, housing cost burden, household composition, and infrastructure access. Table below summarizes each variable, the corresponding ACS table or cell, and the formula used in its construction.

:::: {style="margin:16px 0"}
<center>

<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1111">

<h4 class="text-white">

CBG ReADI Variables

</h4>

</button>

</center>

::: {#code1111 .collapse}
| Census Variable | Name | Table |   |
|------------------|------------------|------------------|:----------------:|
| Median family income, \$ | MEDFI | B19013 | $001$ |
| Income disparity$^a$ | INCDIS | B19001 | $ln({\sum(002-004)+1\over\sum(014-017)+1}x100)$\| |
| Families below poverty level, % | BELPL | B17017 | ${002\over001}x100$ |
| Population below 150% of the poverty threshold, % | PL150 | C17002 | ${\sum(002-005)\over 001}x100$ |
| Population ≥25y with \< a high school diploma, % | EDU9YR | B15003 | ${\sum(002-016)\over 001}x100$ |
| Population ≥25y with at least a bachelor's degree, % | HSDPNHIGH | B15003 | ${\sum(022-025)\over 001}x100$ |
| Employed persons ≥16y in white-collar occupations, % | EMPWC | C24010 | ${\sum(003,027,039,063)\over 001}x100$ |
| Civilian labor force population ≥16 y unemployed, % | UNEMP | B23025 | ${005\over003}x100$ |
| Median home value, \$ | MEDHV | B25077 | $001$ |
| Median gross rent, \$ | MEDRNT | B25064 | $001$ |
| Median monthly mortgage, \$ | MEDMORT | B25088 | $002$ |
| Owner-occupied housing units, % | OWN | B25003 | ${002\over001}x100$ |
| Single-parent households with children \<18y, % | SNGPNT | B11012 | ${\sum(010,015)\over 001}x100$ |
| Households without a motor vehicle, % | NOVEH | B25044 | ${\sum(010,003)\over 001}x100$ |
| Households without internet, % | NOINT | B28002 | ${013\over001}x100$ |
| Occupied housing units without complete plumbing, % | NOPLUM | B25049 | $ln({\sum(004,007)+1\over001+1}x100)$ \| |
| Households with more than 1 person per room, % | CROWD | B25014 | ${\sum(005-007,011-013)\over 001}x100$ |

<sup>$^a$ Income disparity in 2022 was defined as the log of 100×ratio of number of households with \<\$20,000 income to number of households with ≥\$100,000 income.</sup>
:::
::::

<strong><strong>2. Resolve structural zeros:</strong></strong> Any remaining NAs after calculation are not true missing values. They occur only when both the numerator and denominator of a ratio are zero. These structural cases are converted to zero so that they do not propagate into later steps.

<strong><strong>3. Standardize the component variables:</strong></strong> The 17 component variables are standardized using z-scores (mean = 0, standard deviation = 1). Standardization ensures that variables measured on different numerical scales (for example, percentages vs. dollar-valued medians) contribute appropriately to the factor analysis rather than being dominated by variables with large numeric ranges.

<strong><strong>4. Compute population weights:</strong></strong> Population size for each geographic unit is taken from ACS table **B01003_001** (total population). To reduce the influence of extremely large or small areas and to make population distributions more comparable across geographies, we transform the weights using: ${POPWT} = \sqrt{\text{population}} + 1$. These transformed weights are used as analytic weights in the factor model.

<strong><strong>5. Fit the factor model:</strong></strong> A one-factor model is estimated using the *fa()* function from the *psych* package. Key specifications, otherwise default was applied:

-   method: principal factor extraction
-   number of factors: 1
-   weights: population-based POPWT

This procedure produces the following core outputs for each geography:

1.  **ReADI coefficients**: the estimated scoring coefficients for each of the 17 component variables, as derived from the one-factor model.
2.  **Raw ReADI score**: a continuous ADI score for each unit based on the factor solution (unscaled).
3.  **Nationally ranked ReADI score**: the raw ReADI score transformed to a 0–100 national rank, where higher values indicate greater deprivation.
4.  **Factor loadings and weights**: the underlying loadings and scoring weights that describe how each component contributes to the factor and how scores are computed.

Table below shows the number of NAs and the resulting factor weights for block groups.

### Block group (CBG) ReADI

<br>

Below are the factor weights and scoring coefficients estimated for block groups using the 2022 ACS data. These coefficients are applied to the standardized component variables to generate both the raw and nationally ranked ReADI scores at the CBG level. The code below performs the component construction, weighting, factor model estimation, and score generation for block groups.

:::::::::: row
::: col-md-4
:::
::::: col-md-4
:::: {style="margin:16px 0"}
<center>

<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1177">

<h4 class="text-white">

CBG Weights

</h4>

</button>

</center>

::: {#code1177 .collapse}
| Variable  | NAs | Weights |
|:----------|:----|--------:|
| MEDFI     | 0   |  -0.280 |
| INCDIS    | 0   |   0.145 |
| BELPL     | 631 |   0.085 |
| PL150     | 502 |   0.184 |
| EDU9YR    | 81  |   0.065 |
| HSDPNHIGH | 81  |  -0.135 |
| EMPWC     | 445 |  -0.104 |
| UNEMP     | 424 |   0.023 |
| MEDHV     | 0   |  -0.033 |
| MEDRNT    | 0   |  -0.066 |
| MEDMORT   | 0   |  -0.049 |
| OWN       | 631 |   0.005 |
| SNGPNT    | 631 |   0.035 |
| NOVEH     | 631 |   0.025 |
| NOINT     | 631 |   0.059 |
| NOPLUM    | 0   |   0.014 |
| CROWD     | 631 |   0.026 |
:::
::::
:::::

::::: col-md-4
:::::
::::::::::

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1296">Show Code</button>

::: {#code1296 .collapse}
```{r}
ReADI_CBG_2022 <- ReADI_CBG_2022_Imp %>%
  dplyr::mutate(MEDFI = B19013_001,
    INCDIS = log(100*((B19001_002 + B19001_003 + B19001_004 + 1)/(B19001_014 + B19001_015 + B19001_016 + B19001_017 + 1))),
    BELPL = B17017_002/B17017_001*100,
    PL150 = (C17002_005 + C17002_004 + C17002_003 + C17002_002)/C17002_001*100,
    EDU9YR = (B15003_002 + B15003_003 + B15003_004 + B15003_005 + B15003_006 + B15003_007 + B15003_008 + B15003_009 + B15003_010 + B15003_011 + B15003_012 + B15003_013 + B15003_014 + B15003_015 + B15003_016)/B15003_001*100,
    HSDPNHIGH = (B15003_022 + B15003_023 + B15003_024 + B15003_025)/B15003_001*100,
    EMPWC = (C24010_003 + C24010_027 + C24010_039 + C24010_063)/ C24010_001*100,
    UNEMP = B23025_005/B23025_003*100,
    MEDHV = B25077_001,
    MEDRNT = B25064_001,
    MEDMORT = B25088_002,
    OWN = B25003_002/B25003_001*100,
    SNGPNT = (B11012_010 + B11012_015)/B11012_001*100,
    NOVEH = (B25044_010 + B25044_003)/B25044_001*100,
    NOINT = B28002_013/B28002_001*100,
    NOPLUM = log((B25049_007 + B25049_004 + 1)/(B25049_001 + 1)*100),
    CROWD = (B25014_005 + B25014_006 + B25014_007 + B25014_011 + B25014_012 + B25014_013)/B25014_001*100,
    POPWT = log(B01003_001)
) %>%
  select(GEOID, Block_Group, Tract, County, State, MEDFI, INCDIS, BELPL, PL150, EDU9YR, HSDPNHIGH, EMPWC, UNEMP, MEDHV, MEDRNT, MEDMORT, OWN, SNGPNT, NOVEH, NOINT, NOPLUM, CROWD, POPWT)

# Replacing NA values resulting from 0 values back to 0. 
colSums(is.na(ReADI_CBG_2022))
ReADI_CBG_2022[is.na(ReADI_CBG_2022)] <- 0
ReADI_2022_CBG_RawVars <- ReADI_CBG_2022

ADI_short <- ReADI_CBG_2022[, c("GEOID", "MEDFI", "INCDIS", "BELPL", "PL150", "EDU9YR", "HSDPNHIGH", "EMPWC", "UNEMP", "MEDHV", "MEDRNT", "MEDMORT", "OWN", "SNGPNT", "NOVEH", "NOINT", "NOPLUM", "CROWD")]
rownames(ADI_short) <- ADI_short$GEOID
ADI_short$GEOID <- NULL

# zscore transform
ADI_short <- as.data.frame(scale(ADI_short))

# Factor analysis is performed with a one factor solution
stopifnot(identical(rownames(ADI_short), ReADI_CBG_2022$GEOID))
adi.fa <- fa(ADI_short, nfactors = 1, fm = "pa", weight = ReADI_CBG_2022$POPWT)

# Loadings
ReADI_2022_Loadings <- as.data.frame(loadings(adi.fa)[])
colnames(ReADI_2022_Loadings) <- "CBG"
ReADI_2022_Loadings$Vars <- rownames(ReADI_2022_Loadings)
ReADI_2022_Loadings <- ReADI_2022_Loadings[,c(2,1)]

# Weights
ReADI_2022_Wt <- as.data.frame(adi.fa$weights)
colnames(ReADI_2022_Wt) <- "CBG"
ReADI_2022_Wt$Vars <- rownames(ReADI_2022_Wt)
ReADI_2022_Wt <- ReADI_2022_Wt[,c(2,1)]

# Pulling the raw scores as the raw ReADI, producing the ReADI on a scale of 0-100
ADI <- as.data.frame(adi.fa$scores)
colnames(ADI) <- c("ReADI_CBG_Raw")
stopifnot(identical(rownames(ADI), ReADI_CBG_2022$GEOID))
ADI$ReADI_CBG_NR <- round(percent_rank(ADI$ReADI_CBG_Raw)*100, 0)
ADI$GEOID <- rownames(ADI)
ReADI_CBG_2022 <- plyr::join(ReADI_CBG_2022, ADI, by = "GEOID")
save(ReADI_CBG_2022, file = "ReADI_CBG_2022.RData")
write.csv(ReADI_CBG_2022, file = "ReADI_CBG_2022.csv")
```
:::
::::

### Census tract (CT) ReADI

<br>

This section applies the same ReADI procedure at the census tract level. The table below shows the tract-specific factor loadings and scoring coefficients. The code that follows constructs the 17 tract-level component variables, applies population weighting, fits the factor model, and produces both the raw and nationally ranked ReADI values for census tracts.

:::::::::: row
::: col-md-4
:::
::::: col-md-4
:::: {style="margin:16px 0"}
<center>

<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1403">

<h4 class="text-white">

CT Weights

</h4>

</button>

</center>

::: {#code1403 .collapse}
| Variable  | NAs | Weights |
|:----------|:----|--------:|
| MEDFI     | 0   |  -0.308 |
| INCDIS    | 0   |   0.171 |
| BELPL     | 255 |   0.048 |
| PL150     | 198 |   0.224 |
| EDU9YR    | 21  |   0.059 |
| HSDPNHIGH | 21  |  -0.091 |
| EMPWC     | 154 |  -0.129 |
| UNEMP     | 153 |   0.019 |
| MEDHV     | 0   |  -0.020 |
| MEDRNT    | 0   |  -0.036 |
| MEDMORT   | 0   |  -0.002 |
| OWN       | 255 |   0.045 |
| SNGPNT    | 255 |   0.045 |
| NOVEH     | 255 |   0.015 |
| NOINT     | 255 |   0.057 |
| NOPLUM    | 0   |   0.010 |
| CROWD     | 255 |   0.018 |
:::
::::
:::::

::::: col-md-4
:::::
::::::::::

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1417">Show Code</button>

::: {#code1417 .collapse}
```{r}
ReADI_CT_2022 <- ReADI_CT_2022_Imp %>%
  dplyr::mutate(MEDFI = B19013_001,
    INCDIS = log(100*((B19001_002 + B19001_003 + B19001_004 + 1)/(B19001_014 + B19001_015 + B19001_016 + B19001_017 + 1))),
    BELPL = B17017_002/B17017_001*100,
    PL150 = (C17002_005 + C17002_004 + C17002_003 + C17002_002)/C17002_001*100,
    EDU9YR = (B15003_002 + B15003_003 + B15003_004 + B15003_005 + B15003_006 + B15003_007 + B15003_008 + B15003_009 + B15003_010 + B15003_011 + B15003_012 + B15003_013 + B15003_014 + B15003_015 + B15003_016)/B15003_001*100,
    HSDPNHIGH = (B15003_022 + B15003_023 + B15003_024 + B15003_025)/B15003_001*100,
    EMPWC = (C24010_003 + C24010_027 + C24010_039 + C24010_063)/ C24010_001*100,
    UNEMP = B23025_005/B23025_003*100,
    MEDHV = B25077_001,
    MEDRNT = B25064_001,
    MEDMORT = B25088_002,
    OWN = B25003_002/B25003_001*100,
    SNGPNT = (B11012_010 + B11012_015)/B11012_001*100,
    NOVEH = (B25044_010 + B25044_003)/B25044_001*100,
    NOINT = B28002_013/B28002_001*100,
    NOPLUM = log((B25049_007 + B25049_004 + 1)/(B25049_001 + 1)*100),
    CROWD = (B25014_005 + B25014_006 + B25014_007 + B25014_011 + B25014_012 + B25014_013)/B25014_001*100,
    POPWT = log(B01003_001)
) %>%
  select(GEOID, Tract, County, State, MEDFI, INCDIS, BELPL, PL150, EDU9YR, HSDPNHIGH, EMPWC, UNEMP, MEDHV, MEDRNT, MEDMORT, OWN, SNGPNT, NOVEH, NOINT, NOPLUM, CROWD, POPWT)

colSums(is.na(ReADI_CT_2022))
ReADI_CT_2022[is.na(ReADI_CT_2022)] <- 0
ReADI_2022_CT_RawVars <- ReADI_CT_2022

ADI_short <- ReADI_CT_2022[, c("GEOID", "MEDFI", "INCDIS", "BELPL", "PL150", "EDU9YR", "HSDPNHIGH", "EMPWC", "UNEMP", "MEDHV", "MEDRNT", "MEDMORT", "OWN", "SNGPNT", "NOVEH", "NOINT", "NOPLUM", "CROWD")]
rownames(ADI_short) <- ADI_short$GEOID
ADI_short$GEOID <- NULL

ADI_short <- as.data.frame(scale(ADI_short))

stopifnot(identical(rownames(ADI_short), ReADI_CT_2022$GEOID))
adi.fa <- fa(ADI_short, nfactors = 1, fm = "pa", weight = ReADI_CT_2022$POPWT)

# Loadings
identical(colnames(adi.fa$residual),ReADI_2022_Loadings$Vars)
ReADI_2022_Loadings$CT <- loadings(adi.fa)[,"PA1"]

# Weights
identical(colnames(adi.fa$residual),ReADI_2022_Wt$Vars)
ReADI_2022_Wt$CT <- adi.fa$weights[,"PA1"]

# ReADI scores
ADI <- as.data.frame(adi.fa$scores)
colnames(ADI) <- c("ReADI_CT_Raw")
stopifnot(identical(rownames(ADI), ReADI_CT_2022$GEOID))
ADI$ReADI_CT_NR <- round(percent_rank(ADI$ReADI_CT_Raw)*100, 0)
ADI$GEOID <- rownames(ADI)
ReADI_CT_2022 <- plyr::join(ReADI_CT_2022, ADI, by = "GEOID")
save(ReADI_CT_2022, file = "ReADI_CT_2022.RData")
write.csv(ReADI_CT_2022, file = "ReADI_CT_2022.csv")
```
:::
::::


### County (C) ReADI

<br>

Finally, the ReADI procedure is estimated at the county level. The table below displays the county-level factor loadings and scoring coefficients. The code below generates the component variables, applies analytic weights, fits the county factor model, and computes raw and nationally ranked ReADI scores for all counties.

:::::::::: row
::: col-md-4
:::
::::: col-md-4
:::: {style="margin:16px 0"}
<center>

<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1524">

<h4 class="text-white">

C Weights

</h4>

</button>

</center>

::: {#code1524 .collapse}
| Variable  | NAs | Weights |
|:----------|:----|--------:|
| MEDFI     | 0   |  -0.301 |
| INCDIS    | 0   |   0.314 |
| BELPL     | 0   |  -0.085 |
| PL150     | 0   |   0.182 |
| EDU9YR    | 0   |   0.055 |
| HSDPNHIGH | 0   |  -0.069 |
| EMPWC     | 0   |  -0.069 |
| UNEMP     | 0   |   0.013 |
| MEDHV     | 0   |  -0.079 |
| MEDRNT    | 0   |  -0.055 |
| MEDMORT   | 0   |   0.019 |
| OWN       | 0   |   0.051 |
| SNGPNT    | 0   |   0.055 |
| NOVEH     | 0   |  -0.024 |
| NOINT     | 0   |   0.094 |
| NOPLUM    | 0   |   0.016 |
| CROWD     | 0   |   0.044 |
:::
::::
:::::

::::: col-md-4
:::::
::::::::::

:::: {style="margin:16px 0"}
<button type="button" class="btn btn-dark" control-id="ControlID-54" data-bs-toggle="collapse" data-bs-target="#code1532">Show Code</button>

::: {#code1532 .collapse}
```{r}
ReADI_C_2022 <- ReADI_C_2022_Imp %>%
  dplyr::mutate(MEDFI = B19013_001,
    INCDIS = log(100*((B19001_002 + B19001_003 + B19001_004 + 1)/(B19001_014 + B19001_015 + B19001_016 + B19001_017 + 1))),
    BELPL = B17017_002/B17017_001*100,
    PL150 = (C17002_005 + C17002_004 + C17002_003 + C17002_002)/C17002_001*100,
    EDU9YR = (B15003_002 + B15003_003 + B15003_004 + B15003_005 + B15003_006 + B15003_007 + B15003_008 + B15003_009 + B15003_010 + B15003_011 + B15003_012 + B15003_013 + B15003_014 + B15003_015 + B15003_016)/B15003_001*100,
    HSDPNHIGH = (B15003_022 + B15003_023 + B15003_024 + B15003_025)/B15003_001*100,
    EMPWC = (C24010_003 + C24010_027 + C24010_039 + C24010_063)/ C24010_001*100,
    UNEMP = B23025_005/B23025_003*100,
    MEDHV = B25077_001,
    MEDRNT = B25064_001,
    MEDMORT = B25088_002,
    OWN = B25003_002/B25003_001*100,
    SNGPNT = (B11012_010 + B11012_015)/B11012_001*100,
    NOVEH = (B25044_010 + B25044_003)/B25044_001*100,
    NOINT = B28002_013/B28002_001*100,
    NOPLUM = log((B25049_007 + B25049_004 + 1)/(B25049_001 + 1)*100),
    CROWD = (B25014_005 + B25014_006 + B25014_007 + B25014_011 + B25014_012 + B25014_013)/B25014_001*100,
    POPWT = log(B01003_001)
) %>%
  select(GEOID, County, State, MEDFI, INCDIS, BELPL, PL150, EDU9YR, HSDPNHIGH, EMPWC, UNEMP, MEDHV, MEDRNT, MEDMORT, OWN, SNGPNT, NOVEH, NOINT, NOPLUM, CROWD, POPWT)

colSums(is.na(ReADI_C_2022))
ReADI_2022_C_RawVars <- ReADI_C_2022

ADI_short <- ReADI_C_2022[, c("GEOID", "MEDFI", "INCDIS", "BELPL", "PL150", "EDU9YR", "HSDPNHIGH", "EMPWC", "UNEMP", "MEDHV", "MEDRNT", "MEDMORT", "OWN", "SNGPNT", "NOVEH", "NOINT", "NOPLUM", "CROWD")]
rownames(ADI_short) <- ADI_short$GEOID
ADI_short$GEOID <- NULL

ADI_short <- as.data.frame(scale(ADI_short))

stopifnot(identical(rownames(ADI_short), ReADI_C_2022$GEOID))
adi.fa <- fa(ADI_short, nfactors = 1, fm = "pa", weight = ReADI_C_2022$POPWT)

# Loadings
identical(colnames(adi.fa$residual),ReADI_2022_Loadings$Vars)
ReADI_2022_Loadings$C <- loadings(adi.fa)[,"PA1"]
save(ReADI_2022_Loadings, file = "ReADI_2022_Loadings.RData")
write.csv(ReADI_2022_Loadings, file = "ReADI_2022_Loadings.csv")

# weights
identical(colnames(adi.fa$residual),ReADI_2022_Wt$Vars)
ReADI_2022_Wt$C <- adi.fa$weights[,"PA1"]
save(ReADI_2022_Wt, file = "ReADI_2022_Wt.RData")
write.csv(ReADI_2022_Wt, file = "ReADI_2022_Wt.csv")

# ReADI Scores
ADI <- as.data.frame(adi.fa$scores)
colnames(ADI) <- c("ReADI_C_Raw")
stopifnot(identical(rownames(ADI), ReADI_C_2022$GEOID))
ADI$ReADI_C_NR <- round(percent_rank(ADI$ReADI_C_Raw)*100, 0)
ADI$GEOID <- rownames(ADI)
ReADI_C_2022 <- plyr::join(ReADI_C_2022, ADI, by = "GEOID")
save(ReADI_C_2022, file = "ReADI_C_2022.RData")
write.csv(ReADI_C_2022, file = "ReADI_C_2022.csv")
```
:::
::::

<br><br>

# Summary

<br>

At this stage, ReADI has been fully constructed for all three geographic levels. For each level, the workflow produces the calculated scoring coefficients, raw ReADI scores, nationally ranked (0–100) ReADI scores, and the corresponding factor loadings and weights. These outputs form the basis for all subsequent mapping, validation, and comparison analyses. Because all steps are explicitly documented and reproducible, users can subset geographic levels, modify components, or re-estimate the factor model for alternative datasets as needed.
